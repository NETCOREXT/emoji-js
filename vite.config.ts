import fs from 'node:fs/promises'
import path, { resolve } from 'node:path'
import readline from 'node:readline'
import { Readable } from 'node:stream'
import { fileURLToPath } from 'node:url'
import { consola } from 'consola'
import { globSync } from 'glob'
import { defineConfig } from 'vite'
import dts from 'vite-plugin-dts'

async function syncEmoji() {
  return {
    name: 'sync-emoji',
    async buildStart() {
      consola.log('Fetching emoji data...')

      // https://www.unicode.org/Public/emoji/latest/emoji-test.txt
      const emojiUrl = 'https://www.unicode.org/Public/17.0.0/emoji/emoji-test.txt'
      const response = await fetch(emojiUrl)

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const stream = Readable.fromWeb(response.body as any)
      const rl = readline.createInterface({
        input: stream,
        crlfDelay: Infinity,
      })

      let refVersion: string = ''
      let group: string = ''
      let subgroup: string = ''
      let fullyQualified = 0
      let minimallyQualified = 0
      let unqualified = 0
      let component = 0

      let fullyQualifiedCount = 0
      let minimallyQualifiedCount = 0
      let unqualifiedCount = 0
      let componentCount = 0

      // 'fully-qualified' | 'unqualified' | 'minimally-qualified' | 'component'
      const lsEmoji: { code?: string[], emoji?: string, group?: string, subgroup?: string, version?: string, description?: string, status?: string, skinTone?: boolean }[] = []
      // const regex = /^(?<code>[^;]+);\s(?<status>fully-qualified|unqualified|minimally-qualified|component)\s*#\s(?<emoji>[^E]+)\sE(?<version>\d+\.\d+)\s(?<description>.+)$/gimu
      const skinToneRegex = /\p{Emoji_Modifier}/u

      for await (const line of rl) {
        if (line.startsWith('# Version:')) {
          refVersion = line.replace('# Version: ', '').trim()
          continue
        }
        if (line.startsWith('# group:')) {
          group = line.replace('# group: ', '').trim()
          continue
        }

        if (line.startsWith('# subgroup:')) {
          subgroup = line.replace('# subgroup: ', '').trim()
          continue
        }

        if (line.startsWith('# fully-qualified :')) {
          fullyQualified = Number(line.replace('# fully-qualified :', '').trim())
          continue
        }
        if (line.startsWith('# minimally-qualified :')) {
          minimallyQualified = Number(line.replace('# minimally-qualified :', '').trim())
          continue
        }
        if (line.startsWith('# unqualified :')) {
          unqualified = Number(line.replace('# unqualified :', '').trim())
          continue
        }
        if (line.startsWith('# component :')) {
          component = Number(line.replace('# component :', '').trim())
          continue
        }

        // const match = regex.exec(line.trim())

        if (!/^[0-9A-Z ]+/imu.test(line.trim()))
          continue

        const code = /^[^;]+/mu.exec(line.trim())?.[0]?.trim()
        const status = /;\s(fully-qualified|unqualified|minimally-qualified|component)/iu.exec(line.trim())?.[1]?.trim()
        const emoji = /#\s([^E]+)\sE/iu.exec(line.trim())?.[1]?.trim()
        const version = /E(\d+\.\d+)/iu.exec(line.trim())?.[1]?.trim()
        const description = /E\d+\.\d+\s(.+)$/imu.exec(line.trim())?.[1]?.trim()

        if (status === 'fully-qualified')
          fullyQualifiedCount++
        else if (status === 'minimally-qualified')
          minimallyQualifiedCount++
        else if (status === 'unqualified')
          unqualifiedCount++
        else if (status === 'component')
          componentCount++

        // console.log('Line:', line, '=>', { code, status, emoji, version, description, group, subgroup })
        lsEmoji.push({ code: code!.trim().split(' '), status, emoji, version, description, group, subgroup, skinTone: skinToneRegex.test(emoji!) })
      }

      console.log(`Status Counts:\nfully-qualified: ${fullyQualifiedCount}/${fullyQualified}\nminimally-qualified: ${minimallyQualifiedCount}/${minimallyQualified}\nunqualified: ${unqualifiedCount}/${unqualified}\ncomponent: ${componentCount}/${component}`)

      const template = `/** This file is auto generated by @netcorext/emoji-js
 * Reference: ${emojiUrl}
 * Reference Version: ${refVersion}
 * Status Counts:
 * - fully-qualified: ${fullyQualified}
 * - minimally-qualified: ${minimallyQualified}
 * - unqualified: ${unqualified}
 * - component: ${component}
 */
export type EmojiStatus = ${lsEmoji.length === 0 ? 'never' : [...new Set(lsEmoji.map(e => e.status))].map(g => `'${g}'`).join(' | ')}
export type EmojiGroup = ${lsEmoji.length === 0 ? 'never' : [...new Set(lsEmoji.map(e => e.group))].map(g => `'${g}'`).join(' | ')}
export type EmojiSubGroup = ${lsEmoji.length === 0 ? 'never' : [...new Set(lsEmoji.map(e => e.subgroup))].map(g => `'${g}'`).join(' | ')}
export interface Emoji {
  code: string[]
  status: string
  emoji: string
  version: string
  description: string
  group: string
  subgroup: string
  skinTone: boolean
}
export const FULLY_QUALIFIED_COUNT = ${fullyQualified}
export const MINIMALLY_QUALIFIED_COUNT = ${minimallyQualified}
export const UNQUALIFIED_COUNT = ${unqualified}
export const COMPONENT_COUNT = ${component}
export const EMOJI: Emoji[] = ${JSON.stringify(lsEmoji).replaceAll('\'', '\\\'').replaceAll('"', '\'')}`
      const tsPath = resolve('./src/types/emoji.ts')
      await fs.writeFile(tsPath, template)
      consola.log('âœ… emoji.ts has been updated.')
    },
  }
}

export default defineConfig({
  plugins: [
    dts({
      include: ['./src'],
    }),
  ],
  build: {
    lib: {
      entry: [path.resolve(__dirname, 'src/index.ts')],
    },
    rollupOptions: {
      plugins: [syncEmoji()],
      input: Object.fromEntries(
        globSync('src/**/*.ts').map(file => [
          path.relative(
            'src',
            file.slice(0, file.length - path.extname(file).length),
          ),
          fileURLToPath(new URL(file, import.meta.url)),
        ]),
      ),
      output: [
        {
          dir: 'dist',
          format: 'es',
          entryFileNames: '[name].mjs',
        },
        {
          dir: 'dist',
          format: 'cjs',
          entryFileNames: '[name].js',
        },
      ],
    },
    outDir: 'dist',
    emptyOutDir: true,
  },
})
